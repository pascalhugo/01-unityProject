// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;

public class Fighter : MonoBehaviour {
				
	public int damage = 10;
	public float attackRate = 1f;

	private Transform myTr;
	private SoldierType soldierType;

	private bool fighting = false;
	public bool IsFighting {
		get { return fighting; }
	}

	void Start() {
		myTr = transform;
		soldierType = GetComponent<SoldierType> ();
	}


	public void Fight(Alive target) {
		fighting = true;
		if (soldierType.IsMelee) {
			StartCoroutine ("FightCoroutineMelee", target);
		} else {
			StartCoroutine ("FightCoroutineRange", target);
		}
	}

	public void StopFight() {
		fighting = false;
		StopCoroutine("FightCoroutineMelee");
		StopCoroutine("FightCoroutineRange");
	}
	
	private IEnumerator FightCoroutineMelee(Alive target) {
		//Transform attackableSpot = target.GetClosestAttackableSpot( myTr.position );
		//while ( fighting && !target.IsDead && IsCloseEnough(attackableSpot.position) ) {
		while ( fighting && (target != null) && !target.IsDead && IsCloseToFight(target.transform.position) ) {
			SendMessage("OnAttack", target, SendMessageOptions.DontRequireReceiver);
			yield return new WaitForSeconds(.4f);
			target.GetHit( this );
			yield return new WaitForSeconds( attackRate );
		}

		if (fighting && !target.IsDead) {
			SendMessage("OnTargetLost", target, SendMessageOptions.DontRequireReceiver);
		}

		if (target.IsDead) {
			SendMessage("OnTargetDead", target, SendMessageOptions.DontRequireReceiver);
		}

		fighting = false;
	}

	private IEnumerator FightCoroutineRange(Alive target) {
		//Transform attackableSpot = target.GetClosestAttackableSpot( myTr.position );
		//while ( fighting && !target.IsDead && IsCloseEnough(attackableSpot.position) ) {
		while ( fighting && (target != null) && !target.IsDead) {
			SendMessage("OnAttack", target, SendMessageOptions.DontRequireReceiver);
			// A remplacer par une coroutine qui lancera la suite quand la fl√®che atteindra sa cible
			yield return new WaitForSeconds(1f);
			target.GetHit( this );
			yield return new WaitForSeconds( attackRate );
		}

		if (fighting && !target.IsDead) {
			SendMessage("OnTargetLost", target, SendMessageOptions.DontRequireReceiver);
		}

		if (target.IsDead) {
			SendMessage("OnTargetDead", target, SendMessageOptions.DontRequireReceiver);
		}

		fighting = false;
	}

	private bool IsCloseEnough(Vector3 target) {
		bool isCloseX = Mathf.Abs(myTr.position.x - target.x) < 2.15f;
		bool isCloseY = Mathf.Abs(myTr.position.y - target.y) < .2f;
		return isCloseX && isCloseY;
	}
	
	private bool IsCloseTooMuch(Vector3 target) {
		bool isCloseMuchX = Mathf.Abs(myTr.position.x - target.x) < 1.3f;
		return isCloseMuchX;
	}
	
	private bool IsCloseToFight(Vector3 target) {
		return IsCloseEnough (target) && !IsCloseTooMuch (target);
	}
}

